<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>6.5840：Lab2 - Key/Value Server</title>
    <link href="/2025/11/09/6.5840-2/"/>
    <url>/2025/11/09/6.5840-2/</url>
    
    <content type="html"><![CDATA[<h2 id="Key-Value-Server实验"><a href="#Key-Value-Server实验" class="headerlink" title="Key&#x2F;Value Server实验"></a>Key&#x2F;Value Server实验</h2><p>这个实验感觉还是很简单的，上个月（2025-10）月底看完vm-ft论文后没花多久就做完了。感觉与之前做完的Lab1和最近做完的Lab3A相比，这个实验是为了熟悉一下K&#x2F;V存储，对RPC和分布式系统有一个更加深刻的认知，为后面的实验做铺垫，而且个人认为，即使不看vm-ft论文也能做这个实验，具体实验任务和提示都比较详细，除了基于K&#x2F;V服务的分布式锁外，其他任务基本上是“照着做”就行了。</p><p>这里呈上我自己的实现<a href="https://github.com/logicff/mit6.5840">https://github.com/logicff/mit6.5840</a>。</p><h2 id="Fault-Tolerant-Virtual-Machines（vm-ft论文）"><a href="#Fault-Tolerant-Virtual-Machines（vm-ft论文）" class="headerlink" title="Fault-Tolerant Virtual Machines（vm-ft论文）"></a>Fault-Tolerant Virtual Machines（vm-ft论文）</h2><p>理解论文其实不难，主要的点就是VMware FT的主从备份架构和FT Protocol，以及使用replicated state-machines，很多关于如何保证可用性和一致性的细节都有在论文中提到过。个人建议的话，可以先读论文（即使是粗略的读），然后看一下课程，最后再看看6.5840的关于vm-ft的FAQ。</p><h2 id="一点想法"><a href="#一点想法" class="headerlink" title="一点想法"></a>一点想法</h2><ol><li><p>关于FT Protocol的一个可能优化：按照论文中的描述，一个带有输出的请求的大致流程应该是<code>请求发送到主虚拟机-&gt;主虚拟机的VMM向备份虚拟机发送日志条目并让主虚拟机处理请求-&gt;主虚拟机的VMM收到备份虚拟机的确认后转发主虚拟机的输出</code>，如果我们让输出从备份虚拟机发出呢，这样是不是相当于在处理时间相远小于虚拟机之间传输时间的情况下，可以提升整个系统的效率，为了保证一定的正确，备份虚拟机在发出输出的同时向主虚拟机确认即可，这种方案在外部看来从输入到输出相比原方案快了一个主备单向交互时间。不过，我暂时无法验证具体可行性，毕竟对目前的我而言还是很难。</p></li><li><p>面对multi-processor，VMware FT的主备虚拟机无法保证同步，相同的程序在不同的计算机上可能会有不同的指令流。这种情况的一种解决方案是采用内存快照进行同步，但一次内存快照的传输时间可能会很大，我的一个想法是局部快照（比如，只对有变化的内存进行快照，好像已经有个说法叫增量快照了），感觉效率上应该能提升较大。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.5840：Lab1 - MapReduce</title>
    <link href="/2025/10/12/6.5840-1/"/>
    <url>/2025/10/12/6.5840-1/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/6.5840/mapreduce.png" alt="MapReduce Overview"></p><blockquote><p>这里直接引用论文中的图片，本文会忽略一些东西，主要记录一下我自己的理解。</p></blockquote><h2 id="分布式系统的特性"><a href="#分布式系统的特性" class="headerlink" title="分布式系统的特性"></a>分布式系统的特性</h2><ol><li><p>可扩展性。通俗来讲就是如果我用一台计算机解决了一些问题，当我增加第二台计算机后，我只需要一半的时间就可以解决这些问题，或者说每分钟可以解决两倍数量的问题。这在MapReduce中体现为将一个大任务分解成很多的小任务，以便于多个worker同时处理任务。</p></li><li><p>可用性。经过精心的设计，在特定的错误类型下（如某台机器发生故障），系统仍然能够正常运行，仍然可以像没有出现错误一样，提供完整的服务。一般的方法如构建一个多副本系统，其中一个故障了，其他的还能运行，当然如果所有副本都故障了，系统就不再有可用性。这在MapReduce中体现为多个worker可以互为副本，其中一个worker发生故障，可以将其任务交给另一个worker来执行。</p></li><li><p>可恢复性。如果出现了问题，服务会停止工作，不再响应请求，之后有人来修复，并且在修复之后系统仍然可以正常运行，就像没有出现过问题一样，这是一个比可用性更弱的需求。实现可用性和可恢复性这两个特性，有很多方法，其中最重要的两个是非易失存储和副本。</p></li><li><p>一致性。包括多个副本之间要保持一致，不过强一致性的代价非常高，人们可能对弱一致性感兴趣。</p></li></ol><h2 id="MapReduce实验"><a href="#MapReduce实验" class="headerlink" title="MapReduce实验"></a>MapReduce实验</h2><p>与论文所描述的有些不同，实验推荐采用worker向Master请求任务，当然，这是一种简化的做法，实现起来相对比较容易。但有一点，这种情况下，Master处于一个较为被动的情景。其他方面与论文描述的差不多。</p><p>在我看来，实验的有一点设计的比较巧妙，那就是为了保证未完全完成的任务结果影响到其他正常任务，采用创建临时文件保存未完全完成的任务结果，待任务完全完成后进行文件改名的原子性操作。</p><p>很多细节我建议阅读论文以及具体实验任务和提示，这里呈上我自己的实现<a href="https://github.com/logicff/mit6.5840">https://github.com/logicff/mit6.5840</a>。</p><h2 id="一点想法"><a href="#一点想法" class="headerlink" title="一点想法"></a>一点想法</h2><ol><li><p>关于如何按照论文所描述的那样让Master主动分配任务。我的想法是让能够处理任务的worker向Master暴露自己，然后Master将已暴露的worker相关信息保存起来，之后分配任务的时候就可以根据保存的信息进行调度，还有超时检测，相比实验中设置一个超时时间，我认为更加合理的是在已有worker信息的基础上采用心跳检测等机制。</p></li><li><p>关于如何在多台机器上运行实验。其实实验任务中已经给了提示，就是用TCP&#x2F;IP代替Unix sockets。</p></li><li><p>关于进一步提升MapReduce的性能。其实之前的课堂视频上有人提到过采用流式（或者说流水线）的方法进一步提高效率，而不是让Reduce worker等待Map worker全部完成任务。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旧物：回忆是痛苦还是美好？</title>
    <link href="/2025/07/26/oldthings/"/>
    <url>/2025/07/26/oldthings/</url>
    
    <content type="html"><![CDATA[<p>今天准备收拾东西回家，顺便对我那堆杂乱的东西进行一波小整理，于是翻出来了一些旧物，如图：</p><p><img src="/images/oldthings/oldthings1.jpg" alt="一些旧物"></p><p>电子钟是自己亲手焊的，只记得当时空气中弥漫着焊丝（好像是锡丝吧）的味道，真的不想再闻一次。</p><p>塑料冰墩墩是3D打印的，由于这个相当于是一个测试结果，当时老师没有收，就被我拿走了，不过熔融状态的塑料散发出的味道我是不想再闻了。</p><p>圆柱状的东西好像是用来做小零件的材料，忘了是由于什么原因给带走了。</p><p>鸭嘴锤也是自己亲手做的，是做钳工的结果，回想起来好像除了累还是累。</p><p>现在看到这几个东西总有种说不清的感觉，也许是怀念，也许是痛苦，也许只是回忆涌上心头，夹杂着一些惆怅。</p><p>最后这块机械表是高中的时候我妈给我买的，我以前都有看时间的习惯，所以基本上手上都会戴着表，这个习惯对我蛮有影响的，即使现在不戴表了也会时不时看一下时间。这块表好像是大一的时候表带断了，但我没去买新的，就把这块表放口袋里，想看时间的时候就掏出来看一下。后面不知道什么时候坏了，今天翻出来的时候还是有种不一样的感觉的，我想，应该是美好的吧。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
      <tag>回忆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日常：浅浅装一下</title>
    <link href="/2025/07/01/daily-2025-07-01/"/>
    <url>/2025/07/01/daily-2025-07-01/</url>
    
    <content type="html"><![CDATA[<p>事情是这样的，学校有一门极其抽象的特色课程，大家对其的评价都是…</p><p>咳咳，总之难评就是了，我也可以说是被此课程折磨了一学期🤣</p><p>不过，今天这门课的成绩出来了，将近满分，也不枉我被折磨了这么久，转念一想，既然大家都被折磨了（不然这门课也不会“好评如潮”），而我的分数看起来也蛮不错，因此，必须浅浅装一下：</p><p>😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎😎</p><p>（作者精神状态良好）</p><p>言归正传，如果自己以后看到这篇随笔的话，可能会觉得有点无语，不过好歹也算是大学期间的一件令我印象深刻的事情。不过感觉这学期能让我印象深刻的事似乎挺多的，除了这门抽象课外，还有一些积极的，像钢琴、数据库、编译器、SDN等等，不知道以后还记不记得。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>吐槽：流氓软件随意读取相册</title>
    <link href="/2025/06/26/android-gallery-permission-cn/"/>
    <url>/2025/06/26/android-gallery-permission-cn/</url>
    
    <content type="html"><![CDATA[<p>下午在网上surfing时，遇到一条帖子，说是国内某“笔记”软件读取了他&#x2F;她&#x2F;它的手机相册，读取照片四百多次（几乎五百次），不由得一惊，我立马跑去看手机的隐私访问记录（本人安卓手机），然后发现国内某音乐软件读取了我的相册，如图：</p><p><img src="/images/gallery/android-gallery-permission/permission-record1.png" alt="国内某音乐软件读取相册记录1"></p><p><img src="/images/gallery/android-gallery-permission/permission-record2.png" alt="国内某音乐软件读取相册记录2"></p><p>由于系统仅记录近7天的隐私访问记录，遂一时间无法立刻揪出我手机中的所有流氓软件，不过令我震惊的是，此国内某音乐软件每次打开时都会把我的相册扫描一遍，离谱的是，我的相册里总共24个视频全被读取了，总共627张图片被读取了511张。</p><p>至于为什么图片没有被全部读取，应该是因为我的一些图片放在了比较“偏僻”的路径下。好巧不巧，刷到一个知乎回答，答主针对安卓手机做了两个测试App，其中一个是仅允许读取选中的图片，另一个是全程不需要用户参与就自动读取相册中的图片，第一个的结果就不说了，第二个的结果是，答主手机上的7445张照片被读取了4587张，没有全部读取的原因应该和我的一样。</p><p>在这个方面上，国外就做的很不错了，我所用过的国外软件（ins、纸飞机、国内软件的海外版等等）都非常尊重用户的隐私，拿读取照片来说，一般国外软件都会完整地给出“使用选中的照片和视频”、“允许使用全部的照片和视频”、“禁止”这三个选项；而国内软件一般只给两个选项，要么允许要么拒绝，你允许就当你允许全部，你拒绝就“服务不可用”，简直就是流氓。</p><p>话不多说，马上手动设置（没错，还得手动设置，不知道的用户只能不知不觉地承担风险了）一些软件的权限为“使用选中的照片和视频”，还有一些软件由于不支持只能暂时被迫“允许使用全部的照片和视频”。</p><p>我听说，具有私自上传窃听用户隐私的App是没法上架Apple的App Store的，如果这是真的，那么又是羡慕Apple的一天。（还有Google Play）😭</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>相册</tag>
      
      <tag>安全</tag>
      
      <tag>隐私</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git：分布式版本控制系统</title>
    <link href="/2025/06/24/git/"/>
    <url>/2025/06/24/git/</url>
    
    <content type="html"><![CDATA[<p>考完了这学期的期末考试，算是有了一小段空闲时间（大概一周左右），突然想到之前的Git学习还没结束，学习笔记也停了好久，遂浅浅写一篇随笔并继续我的Git学习。</p><h2 id="一、Git是什么？"><a href="#一、Git是什么？" class="headerlink" title="一、Git是什么？"></a>一、Git是什么？</h2><p>Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Linus Torvalds（Linux内核的发明者）称其为“The stupid content tracker”，傻瓜式内容跟踪器。</p><p>对于版本控制，Git采用记录文件的改动的方式来记录版本，而不是每个版本都保存一份完整的备份。例如，在文件的第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”，Git就会把这些改动记录下来。</p><p>不过目前为止，暂时只能跟踪文本文件的改动，比如TXT文件，网页文件，所有的程序代码等等。不幸的是，Word文档的格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的。如果你实在想要利用Git来管理你的Word论文，也不是没有办法，我的一个想法是，可以先用文本文件写论文，图片暂时用文字替代一下，等写完后再全部放到Word中处理格式，听起来有点像写Markdown啊…</p><p>值得学习的是，这种利用局部改动特性的思想。如果你需要写长篇大论的文章，有时候想删除一个段落继续写，又怕将来想恢复找不回来，你会怎么办，或者说怎么去备份呢？一般人可能会这么做，先把当前文件“另存为……”一个文件，再接着改，改到一定程度，再“另存为……”一个文件，这样下去不仅浪费了大量的存储空间，而且文件数量越来越多，难以管理。</p><p>这种思想其实在很多领域都有影子，作为一个CSer，我所了解的就有版本控制、增量备份&#x2F;快照、日志记录、数据库变更等等。</p><p>对于分布式，与集中式相对，Git的分布式特性使得开发者间的协作变得更加灵活多样。我就不详细介绍了，<del>关于分布式我只想吐槽为什么不把“distributed”翻译的更浅显易懂一些，叫“分布式”真是让初学者摸不着头脑，什么听起来高大上的玩意，搞的我当初接触这个概念的时候以为是什么高深技术，一般人学不会的那种，现在看来真是误人子弟</del>。</p><h2 id="二、学习Git"><a href="#二、学习Git" class="headerlink" title="二、学习Git"></a>二、学习Git</h2><p>我就不介绍各种命令该怎么用了，相比官方文档，我只有献丑之技。分享一下目前（2025-06-24）为止我个人的学习经验和避坑指南：</p><p>推荐去<a href="https://git-scm.com/">官方网站</a>学习，在<a href="https://git-scm.com/doc">官方文档Documentation</a>中，不仅可以通过man pages学习具体命令（大部分命令点进去后可以通过右上角区域选择中文，对英语不太好的朋友非常友好），而且可以免费获取官方的书，叫Pro Git，对Git有一个非常详细的介绍，这里奉上中文版链接<a href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a>，可以下载下来慢慢阅读。</p><p>如果你需要的是快速入门，那么你可以去看看廖雪峰的<a href="https://liaoxuefeng.com/books/git/introduction/index.html">Git教程</a>。</p><p>我不太推荐去CSDN学习Git，具体原因就不展开说了，<del>毕竟CSDN的吃相太难看了，风气也难评，学点琐碎的勉强还行，Git学习还是别在CSDN上浪费时间了（相比上面的学习路径）</del>，有官方文档或者优质教程的尽量去看官方文档和优质教程。</p><h2 id="三、一些Git学习记录"><a href="#三、一些Git学习记录" class="headerlink" title="三、一些Git学习记录"></a>三、一些Git学习记录</h2><ul><li><p>2024-07-10：下载Git，开始使用git clone命令</p></li><li><p>2025-04-05：发现除了git clone命令外就不会Git了，于是开始学习Git</p></li><li><p>2025-04-07：到目前（2025-04-07）为止已经学习完了(git) config, init, clone, add, commit, status, diff, log等命令，还有工作目录、暂存区域以及Git仓库的概念，但由于其他事情暂停Git的学习</p></li><li><p>2025-06-24：继续Git的学习，又学习了(git) rm, mv, reset, checkout, reflog等命令</p></li><li><p>2025-06-25：学习了HEAD、Index和Working Directory这三个区域的概念，以及(git) reset, checkout是如何操纵这三个区域的</p></li><li><p>2025-06-26：了解了(git) remote, fetch, pull, push，想在Github上建个仓库继续学习Git；与此同时，突然想起之前做SDN实验时，用vscode就能简单地“图形化”Git，当我看到Ryu的Git仓库图形时，开始思考用这种“图形化界面”会不会更好呢，毕竟花更少的时间就能得到不错的效益</p></li><li><p>2025-06-27：Git远程仓库基础实操</p></li><li><p>2025-06-28：学习Git标签，分支创建、合并、管理</p></li><li><p>2025-06-29：大概学了一下解决分支合并冲突，但由于其他事情暂停Git的学习，不过Git学的应该差不多了，暂停Git的学习不代表暂停Git的使用</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>版本控制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本站指引</title>
    <link href="/2025/06/22/top/"/>
    <url>/2025/06/22/top/</url>
    
    <content type="html"><![CDATA[<p>你好呀！很高兴你能点开这个页面。这里是我的个人博客，一个用文字记录思考、分享故事的空间。如果你是第一次来访，这篇指引将帮你快速熟悉博客的「地形」，找到你感兴趣的内容。</p><h2 id="一、我会分享什么"><a href="#一、我会分享什么" class="headerlink" title="一、我会分享什么"></a>一、我会分享什么</h2><p>这个博客就像我的「数字笔记」，主要收录三大类内容：</p><h3 id="1-技术探索"><a href="#1-技术探索" class="headerlink" title="1. 技术探索"></a>1. 技术探索</h3><ul><li><p>作为一名「CSer」，这里会分享计算机科学与技术领域相关的学习笔记与技术探索</p></li><li><p>项目踩坑实录、工具效率指南</p></li><li><p>也有可能分享其他领域的技术探索</p></li></ul><h3 id="2-生活碎片"><a href="#2-生活碎片" class="headerlink" title="2. 生活碎片"></a>2. 生活碎片</h3><ul><li><p>人生旅行途中遇到的有趣灵魂与优美风景</p></li><li><p>偶尔也会发点「无用美学」</p></li></ul><h3 id="3-成长思考"><a href="#3-成长思考" class="headerlink" title="3. 成长思考"></a>3. 成长思考</h3><ul><li><p>关于自我提升、阅读感悟等的深度复盘</p></li><li><p>也会记录一些笨拙但真实的试错经历</p></li></ul><h2 id="二、如何快速找到感兴趣的内容"><a href="#二、如何快速找到感兴趣的内容" class="headerlink" title="二、如何快速找到感兴趣的内容"></a>二、如何快速找到感兴趣的内容</h2><p>如果觉得文章「眼花缭乱」，可以试试这些「导航工具」：</p><h3 id="1-菜单栏的分类与标签"><a href="#1-菜单栏的分类与标签" class="headerlink" title="1. 菜单栏的分类与标签"></a>1. 菜单栏的分类与标签</h3><ul><li><p>「分类」模块帮你按「大主题」筛选内容，点击任意分类，即可查看该类别的所有文章</p></li><li><p>「标签」模块像一个个「关键词路标」，点击标签可聚合所有相关内容</p></li></ul><h3 id="2-菜单栏的搜索功能"><a href="#2-菜单栏的搜索功能" class="headerlink" title="2. 菜单栏的搜索功能"></a>2. 菜单栏的搜索功能</h3><ul><li>「搜索」模块支持全文检索，直接输入你感兴趣的关键词，就能快速定位目标文章</li></ul><h3 id="3-菜单栏的归档部分"><a href="#3-菜单栏的归档部分" class="headerlink" title="3. 菜单栏的归档部分"></a>3. 菜单栏的归档部分</h3><ul><li>「归档」模块会简单地按照时间顺序显示所有文章，适合喜欢简洁的朋友</li></ul><h2 id="三、写在最后"><a href="#三、写在最后" class="headerlink" title="三、写在最后"></a>三、写在最后</h2><p>本站还在不断「生长」，未来可能会加入更多的功能和内容。如果你有任何建议或者想法，欢迎通过「关于」模块中的联系方式告诉我。</p><p>最后，谢谢你的停留，希望你能在这里找到一片「属于自己的文字角落」。</p>]]></content>
    
    
    <categories>
      
      <category>说明</category>
      
    </categories>
    
    
    <tags>
      
      <tag>说明</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RSS：回归主动阅读时代</title>
    <link href="/2025/06/16/rss/"/>
    <url>/2025/06/16/rss/</url>
    
    <content type="html"><![CDATA[<p>打开各种App，“个性化”算法推送的永远是“你可能喜欢”的内容：重复的热点话题、同质化的短视频、被流量逻辑扭曲的“优质内容”。算法构建的信息茧房里，看似拥有无限选择，可实际上已经被困在“精心设计”的信息牢笼里——</p><ul><li><p>重要的内容被折叠在信息流深处</p></li><li><p>小众但高质量的内容“永远”得不到推荐</p></li><li><p>被动接收的信息碎片正在取代主动阅读</p></li></ul><p>而RSS能让信息获取回归“主动模式”，这就是为什么大家需要RSS。同时，本站已支持RSS订阅。</p><h2 id="一、什么是RSS？"><a href="#一、什么是RSS？" class="headerlink" title="一、什么是RSS？"></a>一、什么是RSS？</h2><p>RSS（简易信息聚合），即Really Simple Syndication，简单来说它是一种内容订阅协议。当网站更新内容时，会生成一个包含标题、摘要、链接的XML文件（即RSS Feed），用户可以通过RSS阅读器订阅这些Feed，就能在一个界面集中查看所有关注网站的新内容。</p><p>打个比方，就像是从一堆分散的报纸杂志中把你需要的分离出来，并统一投递到你的“数字报箱”，从此无需去各个网页走一遍，也不必担心错过关注的网站的更新。</p><h2 id="二、如何使用"><a href="#二、如何使用" class="headerlink" title="二、如何使用"></a>二、如何使用</h2><h3 id="1-找到订阅链接"><a href="#1-找到订阅链接" class="headerlink" title="1. 找到订阅链接"></a>1. 找到订阅链接</h3><p>首先在网站上找到RSS订阅的图标或链接，如果是图标的话一般可以通过右键（PC端）或长按（移动端）获取订阅链接。</p><p>以本站为例，本站的RSS链接在导航栏中，你会得到<a href="https://logicff.github.io/atom.xml">https://logicff.github.io/atom.xml</a>。将RSS地址复制下来以后，你就可以在阅读器中添加并进行订阅了。</p><h3 id="2-选择合适的RSS阅读器"><a href="#2-选择合适的RSS阅读器" class="headerlink" title="2. 选择合适的RSS阅读器"></a>2. 选择合适的RSS阅读器</h3><p>我推荐使用浏览器插件的方式，当然，还有在线网站、客户端等方式可供选择。</p><p>这里介绍浏览器插件的方式。如果你是使用Chrome，那么请打开Chrome的应用商店，搜索“RSS”即可，可以选择RSS Feed Reader或者RSS Subscription Extension（由Google提供）进行安装，也可以自行选择其他插件安装，安装完成后按照说明或者自行搜索使用方法进行使用。</p><p>其他浏览器大同小异，比如Firefox扩展中搜索“RSS”发现暂时没有上述两个插件，可以选择搜索结果中的Feedbro。</p><h3 id="3-开启RSS订阅之旅"><a href="#3-开启RSS订阅之旅" class="headerlink" title="3. 开启RSS订阅之旅"></a>3. 开启RSS订阅之旅</h3><p>将复制的RSS订阅链接导入RSS阅读器中即可。</p><h2 id="三、立刻行动"><a href="#三、立刻行动" class="headerlink" title="三、立刻行动"></a>三、立刻行动</h2><p>现在，你可以开始RSS订阅，开启主动阅读时代。信息爆炸的时代，大家更需要一片能自主耕耘的“数字田园”。RSS不仅是一个工具，也是一种对抗信息焦虑的生活方式，期待通过这种纯粹的方式，把喜欢的内容源牢牢握在手中。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1. <a href="https://www.ruanyifeng.com/blog/2006/01/rss.html">阮一峰的网络日志：如何使用RSS</a></p><p>2. <a href="https://zhuanlan.zhihu.com/p/55026716">知乎：如何用RSS订阅？</a></p>]]></content>
    
    
    <categories>
      
      <category>信息获取</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RSS</tag>
      
      <tag>阅读</tag>
      
      <tag>信息</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
